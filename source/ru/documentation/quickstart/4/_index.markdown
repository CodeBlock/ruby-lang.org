И так, разглядывая детально нашу новую программу, включая первоначальную строку, которая начинается
со знака диез `#`. В Ruby, любая строка которая находится после символа диез, комментарий который 
игнорируется интерпретатором. Первая строка файла специальное значение, для семейства операционных систем Unix, передает оболочке как выполнить файл. Остальная часть комментариев здесь просто для пояснения.

Наш `say_hi` немного усложнился:

``` ruby
    # Say hi to everybody
    def say_hi
      if @names.nil?
        puts "..."
      elsif @names.respond_to?("each")
        # @names is a list of some kind, iterate!
        @names.each do |name|
          puts "Hello #{name}!"
        end
      else
        puts "Hello #{@names}!"
      end
    end
```

Теперь он просматривает `@name` экземпляр переменной для того чтобы принять решение. Если он `nil`, 
он просто выведет три точки. Нет смысла приветствовать никого, правда же?

## Циклы и повторы, – Итерации

Если `@names` объект отвечает на вызов `each`, это значит, что вы можете итерировать его, – перебирать и здороваться с 
каждым человеком.
И наконец, если `@names` что-то еще, мы преобразуем его в `string` автоматически и отприветствуем его классическим для нас способом.

Давайте рассмотрим этот итератор немного ближе:

``` ruby
    @names.each do |name|
      puts "Hello #{name}!"
    end
```

`each` это метод, который принимает блок кода между `do` и `end`, затем его запускает для каждого элемента в списке. Блоки это как анонимные функции или `lambda`.
Переменные между длинной чертой `|` является параметрами для блока.

Что же происходит здесь, для каждой записи в списке? `name` содержит элемент этого списка, а потом выражение `puts #{name}` запускается с этим именем.

Большинство других языков программирования проходятся по списку используя `for` для повтора, который в C смотрится
примерно так:

``` ruby
    for (i=0; i < number_of_elements; i++)
    {
      do_something_with(element[i]);
    }
```

Конечно это работает, но выглядит не шикарно, правда же? Вам нужна временная переменная как `i` например, 
определить насколько длинный список, и объяснить как ему пройтись по нему.
Ruby намного элегантней, все эти технические детали скрыты в методе `each`, все что вам нужно сделать, это 
сообщить что вы хотите сделать с элементом из списка. Внутри, метод `each`, будет по существу вызывать `yield "Albert"`, а потом `yield "Brenda"` и `yield "Charles"`, ну и так далее.

## Блоки, сверкающий блеск граней Ruby

Настоящая сила блоков раскрывается, когда вы имеете дело с вещами, которые являются более сложными, нежели списки.
Помимо обработки внутри метода, мелких технических деталей, вы также можете манипулировать начальными и последующие действиями, а также ошибками – и все это спрятано куда подальше, от забот пользователя.

``` ruby
    # Say bye to everybody
    def say_bye
      if @names.nil?
        puts "..."
      elsif @names.respond_to?("join")
        # Join the list elements with commas
        puts "Goodbye #{@names.join(", ")}.  Come back soon!"
      else
        puts "Goodbye #{@names}.  Come back soon!"
      end
    end
```

`say_bye` метод не использует `each`, вопреки он проверяет отвечает ли `@names` на вызов метода `join`, и если да, то использует его. В противном случае, он просто отобразит нам переменную как `string`. Этот метод не интересует, `type` переменной, он просто полагается на поддержку данных методов, действует по принципу “Утиная типизация”, звучит как “Ну если ходит как утка, и квакает как утка – определенно утка...”. 
Преимущество этого, заключается в том что оно не ограничивает типы переменных которые поддерживает. Если кто-нибудь придет с новым вариантом списка класса, то пока в нем будет реализован метод `join` с такой же семантикой, все будет работать как было задумано.

## Отбрасываем скрипт

В общем, это весь MegaGreeter класс, остальная часть файла просто вызывает методы этого класса.
Здесь есть один последний трюк, на который стоит обратить внимание, на линию:

``` ruby
    if __FILE__ == $0
```

`__FILE__` магическая переменная которая содержит в себе имя данного файла. `$0` имя файла которое используется для запуска программы. Таким образом, мы проверяем “Если используется один и тот же файл...” Это позволяет файл использовать как библиотеку, и не интерпретировать код который находится внутри, но если файл используется как исполняемый, тогда выполнить код.

## Считайте себя ознакомленным

Пожалуй, этого достаточно для быстрого введения в Ruby. Ещё много чего можно исследовать дальше, различные управляющие конструкции, имеющиеся в Ruby; использование блоков и метода yield; модули в роли примесей и многое другое. Надеюсь, немного распробовав Ruby, вы захотите изучить больше.

Если так, прошу направиться в наш раздел Документация, который охватывает много ссылок на руководства и учебники, свободно доступных в Сети.

Или же, если вам действительно захотелось углубиться в какую-нибудь книгу, обратитесь к списку книг в поисках изданий, которые продаются через Сеть или в ближайшем книжном магазине.